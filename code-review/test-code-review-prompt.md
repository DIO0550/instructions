# テストコードレビュープロンプト

目的: テストコードの品質、可読性、保守性を向上させる。テストの意図が明確で、適切な粒度と網羅性を持ち、メンテナンスしやすいテストスイートを構築する。

## レビューポリシー

### テストの基本原則

- **FIRST 原則**: Fast(高速)、Independent(独立)、Repeatable(再現可能)、Self-Validating(自己検証)、Timely(適時)
- **AAA パターン**: Arrange(準備)、Act(実行)、Assert(検証)の明確な分離
- **テストピラミッド**: Unit > Integration > E2E の適切なバランス
- **1 テスト 1 観点**: 1 つのテストで 1 つの振る舞いのみを検証

### 優先度の高いレビュー観点

1. **テストの意図と網羅性**: 何をテストしているかが明確で、重要な振る舞いが漏れていない
2. **テストの独立性**: 他のテストに依存せず、実行順序に関係なく成功する
3. **可読性とメンテナンス性**: テスト名と内容で仕様が理解でき、変更に強い
4. **適切なモックとスタブ**: 外部依存を適切に分離し、テスト対象を明確化

## 基本チェックリスト

### テスト構造と命名

- [ ] テスト名が「何を」「どういう条件で」「どうなるか」を表現しているか
- [ ] describe/context のネストが適切で、テストの分類が明確か
- [ ] AAA パターン(Arrange/Act/Assert)が明確に分離されているか
- [ ] 1 つのテストで複数のアサーションをしすぎていないか

### テストの独立性と再現性

- [ ] テスト間でデータや状態を共有していないか
- [ ] setUp/tearDown で適切にテスト環境をリセットしているか
- [ ] 時間依存やランダム性のあるテストが固定されているか
- [ ] 外部サービスへの依存がモック化されているか

### アサーションの品質

- [ ] アサーションが具体的で、期待値が明確か
- [ ] エラーメッセージが分かりやすく、デバッグしやすいか
- [ ] 境界値テストが含まれているか
- [ ] 異常系テストが適切に含まれているか

### モックとスタブ

- [ ] モックが必要最小限で、過度にモック化していないか
- [ ] モックの期待値設定が実際の使用パターンと一致しているか
- [ ] スタブの戻り値がリアルなデータになっているか
- [ ] モックの検証(toHaveBeenCalledWith 等)が適切か

## 詳細レビューガイド

### テスト名の命名規則

```typescript
// 悪い例
test('user creation', () => { ... });

// 良い例
test('有効なメールアドレスでユーザーを作成すると、IDが生成されて保存される', () => { ... });
test('重複するメールアドレスでユーザー作成を試行すると、ConflictErrorが発生する', () => { ... });
```

### AAA パターンの適用

```typescript
test("商品を在庫数以上注文すると、InsufficientStockErrorが発生する", () => {
  // Arrange
  const product = new Product("laptop", 5); // 在庫5個
  const order = new Order();

  // Act & Assert
  expect(() => {
    order.addItem(product, 6); // 6個注文
  }).toThrow(InsufficientStockError);
});
```

### テストデータの管理

```typescript
// 悪い例: マジックナンバーと意味不明なデータ
const user = { id: 123, name: "John", age: 25 };

// 良い例: 意図が明確なテストデータ
const createValidUser = () => ({
  id: generateUserId(),
  email: "valid@example.com",
  age: 20, // 成人ユーザー
});

const createMinorUser = () => ({
  id: generateUserId(),
  email: "minor@example.com",
  age: 17, // 未成年ユーザー
});
```

## テスト種別ごとの観点

### Unit Test (単体テスト)

- [ ] 1 つのクラス/関数の責務のみをテストしているか
- [ ] 外部依存がすべてモック化されているか
- [ ] 実行時間が短い(数ミリ秒)か
- [ ] 境界値や例外ケースが網羅されているか

### Integration Test (統合テスト)

- [ ] 複数のコンポーネント間の連携をテストしているか
- [ ] データベースやファイルシステムなどの実際のリソースを使用しているか
- [ ] テスト用のデータベースやリソースが適切に管理されているか
- [ ] テスト実行後のクリーンアップが適切か

### E2E Test (End-to-End テスト)

- [ ] ユーザーの実際の利用シナリオをテストしているか
- [ ] UI 操作が安定して実行できるか(待機処理等)
- [ ] テストデータの準備と後処理が適切か
- [ ] 実行時間が許容範囲内か

## 禁止/改善対象

### アンチパターン

- **テストのテスト**: モックの内部実装をテストしている
- **過度なモック化**: 本来テストすべき部分までモック化
- **脆いテスト**: 実装の些細な変更でテストが壊れる
- **遅いテスト**: 不必要にデータベースやネットワークを使用
- **重複テスト**: 同じロジックを複数の場所でテスト

### よくある問題と解決策

```typescript
// 悪い例: 実装詳細をテスト
expect(userService.validateEmail).toHaveBeenCalledWith("test@example.com");

// 良い例: 振る舞いをテスト
const result = await userService.createUser({ email: "test@example.com" });
expect(result.isValid).toBe(true);
```

## レビューコメントのテンプレート

### テスト構造の改善

```
🔴 テスト名が不明確: 「何をテストしているか」「期待される結果」を含めて具体化してください
例: `test('正常系') → test('有効な入力で処理を実行すると、期待される結果が返る')`
```

### アサーションの改善

```
🟡 アサーションが曖昧: toBeTruthy() の代わりに、具体的な値での検証を推奨
例: `expect(result).toBeTruthy() → expect(result.status).toBe('success')`
```

### モックの改善

```
🟡 不要なモック: この部分は実際のオブジェクトを使用してテストできます
理由: [具体的な理由を記載]
```

### テストデータの改善

```
🟢 テストデータが不明確: マジックナンバーや意味不明な値を名前付き定数に置き換えることを推奨
例: `const VALID_AGE = 20; // 成人年齢`
```

## 重要度分類

### 🔴 Blocking (即修正が必要)

- テストが失敗している、または不安定
- セキュリティに関わる重要な振る舞いがテストされていない
- テスト間で状態を共有している
- 本番環境に影響を与える可能性のあるテスト

### 🟡 Should Fix (修正を強く推奨)

- テストの意図が不明確
- 過度なモック化により、統合不具合を見逃すリスク
- テストの実行時間が長すぎる
- 重要な境界値テストが不足

### 🟢 Nice to Have (改善提案)

- テスト名の表現をより分かりやすく
- テストデータの可読性向上
- テストコードの重複排除
- アサーションメッセージの改善

## 特記事項

### フレームワーク固有の観点

- **Jest**: `describe.each` や `test.each` の活用でテストケースを効率化
- **React Testing Library**: ユーザー視点でのテスト(getByRole 等の使用)
- **Cypress/Playwright**: Page Object パターンの適用

### パフォーマンス考慮

- 並列実行可能なテスト設計
- 重いセットアップの最小化
- テストデータベースの効率的な管理

この方針に基づき、テストコードが「読みやすく」「保守しやすく」「信頼できる」ものになることを目指します。
